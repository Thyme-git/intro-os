\documentclass{paper}
\usepackage[UTF8]{ctex}
\usepackage{graphicx}  %插入图片
\usepackage[export]{adjustbox}
\usepackage{float}
\usepackage{geometry}
\usepackage{amssymb}
\usepackage{indentfirst}
% \usepackage{biblatex}
\usepackage[ruled,linesnumbered]{algorithm2e}
\usepackage[colorlinks,linkcolor=blue,bookmarksopen=true,bookmarksnumbered=true]{hyperref}
\usepackage{pythonhighlight}
\usepackage{color}
\usepackage{ulem}

\setlength{\parindent}{4em}
\setlength{\parskip}{1em}
\geometry{a4paper,scale=0.8}
\SetKwInput{KwIn}{输入}
\SetKwInput{KwOut}{输出}

% \usepackage{listings}
\usepackage{ctex}

% 用来设置附录中代码的样式

\usepackage{listings}
% \usepackage{color}
\usepackage{fontspec}

% 定义Monaco字体
\newfontfamily\Monaco{Monaco}

% 配置lstlisting环境，设置Monaco字体
\lstset{
    language=C,
    basicstyle=\linespread{1.0}\small\Monaco,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{blue},
    stringstyle=\color{purple},
    numbers=left,
    numberstyle=\tiny\Monaco,
    stepnumber=1,
    backgroundcolor=\color{white},
    frame=single,
    frameround=false,
    showspaces=false,
    showstringspaces=false,
    breaklines=true
}

\begin{document}

% 目录
\tableofcontents
\newpage

\section{实验二：Binary Bomb}

\subsection{实验概述}

在本次实验中，我需要使用上课所学的内容拆除一个二进制炸弹（Binary Bomb）。二进制炸弹的拆除过程一共有六个阶段，分别是\verb|phase_1|～\verb|phase_6|。在拆除炸弹的每个阶段，我需要分别输入一个字符串，并且使得在每个阶段中二进制炸弹不会调用\verb|explode_bomb|函数。在本次实验中，拆除炸弹的难度随着每个阶段递增。每个阶段考察的内容如下所示。

\begin{itemize}
    \item 阶段 1：字符串比较
    \item 阶段 2：循环
    \item 阶段 3：条件/分支
    \item 阶段 4：递归调用和栈
    \item 阶段 5：指针
    \item 阶段 6：链表/指针/结构
\end{itemize}

除此之外，本实验还有一个隐藏阶段，需要在阶段四输入特定的字符串进行才会出现。
本实验要求我熟练的掌握和使用GDB调试工具以及OBJDUMP工具。其中GDB调试工具用于调试程序，OBJDUMP工具则用于显示二进制炸弹的反汇编代码。

\subsection{实验内容}

在本次实验中，拆除炸弹的过程主要分为七个阶段，其中第七个阶段是隐藏阶段，将在进行完六个主要阶段后开展。

为了便于后续实验能够顺利地进行，在开展实验之前，我首先需要使用\verb|objdump|工具将可执行文件的反汇编代码保存下来。具体方法是使用如下语句：

\verb|objdump -D ./bomb > ./bomb.s|

使用上述语句即可将反汇编之后输出的结果保存在\verb|bomb.s|文件中了。其中\verb|-D|选项表示将可执行文件中所有的节进行反汇编。

接着我还需要分析实验包中的\verb|bomb.c|文件，便于后续拆除炸弹。\verb|bomb.c|文件主要的代码部分如下所示：

\begin{lstlisting}
input = read_line();
phase_1(input);
phase_defused();
printf("Phase 1 defused. How about the next one?\n");

input = read_line();
phase_2(input);
phase_defused();
printf("That's number 2.  Keep going!\n");

input = read_line();
phase_3(input);
phase_defused();
printf("Halfway there!\n");

input = read_line();
phase_4(input);
phase_defused();
printf("So you got that one.  Try this one.\n");

input = read_line();
phase_5(input);
phase_defused();
printf("Good work!  On to the next...\n");

input = read_line();
phase_6(input);
phase_defused();
\end{lstlisting}

分析上述代码可知，每一个\verb|phase|函数的输入参数都一样，都是一个字符串\verb|input|。而\verb|input|字符串又是\verb|read_line|函数的返回值，即从标准输入中送入程序的一个字符串。要将炸弹拆除，我只需要在六个阶段分别输入相应的字符串即可。

\subsubsection{阶段1 字符串匹配}
\begin{enumerate}
    \item 任务描述
    
            找出\verb|phase_1|中使用的程序中保存的字符并输入相同的字符串以通过本关卡。
    
    \item 实验设计

            在反汇编文件\verb|bomb.s|中查找\verb|phase_1|的汇编代码。找到程序中保存的字符串的地址并用\verb|gdb|打印出相应的字符串。
            
    \item 实验过程

            \begin{enumerate}
                \item 寻找\verb|phase_1|函数的代码并查看字符串的地址
                        
                        在vscode中按下\verb|Ctrl+F|按键，并在弹出的提示框中输入\verb|phase_1|即可定位到\verb|phase_1|的代码段。代码段如下所示：

                        \begin{lstlisting}
08048b33 <phase_1>:
 8048b33:	83 ec 14             	sub    $0x14,%esp
 8048b36:	68 24 a0 04 08       	push   $0x804a024 // 参数：保存的字符串
 8048b3b:	ff 74 24 1c          	push   0x1c(%esp) // 输入的字符串
 8048b3f:	e8 e6 04 00 00       	call   804902a <strings_not_equal>
 8048b44:	83 c4 10             	add    $0x10,%esp
 8048b47:	85 c0                	test   %eax,%eax
 8048b49:	74 05                	je     8048b50 <phase_1+0x1d>
 8048b4b:	e8 d1 05 00 00       	call   8049121 <explode_bomb>
 8048b50:	83 c4 0c             	add    $0xc,%esp
 8048b53:	c3                   	ret
                        \end{lstlisting}

                        函数的第一行\verb|sub $0x14,%esp|首先为\verb|phase_1|分配了\verb|0x14|的栈帧空间。此时\verb|%esp+0x14|即是函数的返回地址，而\verb|%esp+0x18|则是\verb|phase_1|函数的输入，即\verb|main.c|文件中看到的\verb|input|参数。

                        在函数的第二行中\verb|push $0x804a02|将保存的字符串地址压入栈中，作为\verb|strings_not_equal|函数的一个参数。此时\verb|%esp|的值减少了了\verb|0x4|，\verb|input|的地址变为\verb|%esp+0x18+0x4 = %esp+0x1c|。

                        接着，在函数的第三行中，\verb|push 0x1c(%esp)|将\verb|input|压入栈中，作为\verb|strings_not_equal|函数的另一个参数。

                \item 使用\verb|gdb|调试程序，并查看\verb|0x804a024|地址下字符串的值。
                        
                        首先使用以下命令进入\verb|gdb|交互模式：

                        \verb|gdb ./bomb|

                        接着使用以下命令查看\verb|0x804a024|地址下字符串的值：

                        \begin{lstlisting}
(gdb) x /s 0x804a024
0x804a024:      "I am just a renegade hockey mom."
                        \end{lstlisting}

                        由\verb|gdb|输出的结果可知，"I am just a renegade hockey mom."即是我们需要输入的字符串。

            \end{enumerate}

    \item 实验结果
            
            将上述字符串通输入到\verb|ans.txt|中并运行程序，通过了第一个关卡。

            \begin{lstlisting}
$ echo "I am just a renegade hockey mom." >> ans.txt
$ ./bomb ans.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
            \end{lstlisting}

\end{enumerate}

\subsubsection{阶段2 循环结构}
\begin{enumerate}
\item 任务描述

分析\verb|phase_2|代码，并从循环结构中分析出需要输入的数字以破解本关卡。

\item 实验设计

本阶段实验主要分为以下几个步骤：

\begin{enumerate}
\item 找出需要输入的数字个数；
\item 找到数字存放的位置；
\item 找出所需要输入的数字具体的值。 
\end{enumerate}

\item 实验过程

\begin{enumerate}
\item 找出需要输入的数字个数

查看\verb|phase_2|反汇编代码可以发现以下用于读取数字的函数\verb|read_six_numbers|，相关代码如下所示：

\begin{lstlisting}[label={Read},caption={Read}]
8048b6e:	e8 d3 05 00 00       	call   8049146 <read_six_numbers>
8048b73:	83 c4 10             	add    $0x10,%esp
8048b76:	83 7c 24 04 01       	cmpl   $0x1,0x4(%esp)
\end{lstlisting}

通过函数的名称很容易知道我们需要输入的数字个数是\verb|6|个。

\item 找到数字存放的位置

在\verb|read_six_numbers|函数返回后，可以发现，在代码\ref{Read}中的地址\verb|0x8048b76|处将\verb|0x4(%esp)|与\verb|0x1|作比较，因此我们可以合理推测出所读入的数字存放在\verb|0x4+%esp|附近。

接着使用\verb|gdb|验证上述猜想：

\begin{lstlisting}[language=C]
$ gdb ./bomb
(gdb) b *0x8048b76 // 上述代码中的cmpl 0x1, 0x4(%esp)语句处设置断点
Breakpoint 1 at 0x8048b76
(gdb) r ans.txt // ans中已经保存了第一关的答案
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
1 1 4 5 1 4 // 第二关的输入测试

Breakpoint 1, 0x08048b76 in phase_2 ()
(gdb) x /6uw 0x4+$esp // 通过观察0x4+$esp中的内容
0xffffc954:     1       1       4       5
0xffffc964:     1       4
\end{lstlisting}

通过观察\verb|0x4+$esp|中的内容可以发现，我们输入的数字存放在以\verb|0x4+$esp|为首地址的连续内存中。

\item 找出所需要输入的数字具体的值 

接着分析代码段，找出第一个数字的值：

\begin{lstlisting}
8048b76:	83 7c 24 04 01       	cmpl   $0x1,0x4(%esp) // 第一个数字
8048b7b:	74 05                	je     8048b82 <phase_2+0x2e>
8048b7d:	e8 9f 05 00 00       	call   8049121 <explode_bomb>
8048b82:	8d 5c 24 04          	lea    0x4(%esp),%ebx
\end{lstlisting}

上述代码段的逻辑十分简单，即：若第一个数字等于\verb|0x1|则跳过\verb|explode_bomb|函数。因此，我们需要输入的第一个数字是\verb|1|。

分析接下来的循环结构代码，得出剩下数字的值：

\begin{lstlisting}
8048b82:	8d 5c 24 04        lea    0x4(%esp),%ebx // 首地址
8048b86:	8d 74 24 18        lea    0x18(%esp),%esi // 尾地址
8048b8a:	8b 03              mov    (%ebx),%eax // loop start
8048b8c:	01 c0              add    %eax,%eax
8048b8e:	39 43 04           cmp    %eax,0x4(%ebx)
8048b91:	74 05              je     8048b98 <phase_2+0x44>
8048b93:	e8 89 05 00 00     call   8049121 <explode_bomb>
8048b98:	83 c3 04           add    $0x4,%ebx
8048b9b:	39 f3              cmp    %esi,%ebx
8048b9d:	75 eb              jne    8048b8a <phase_2+0x36> // loop end
\end{lstlisting}

由\verb|0x18 = 24 = 6*sizeof(int)|可知，\verb|0x18+%esp|是第六个数字的地址。分析上述代码：进入循环前程序先将数组的首地址存放在\verb|%ebx|中，将数组的尾地址存放在\verb|%esi|中。进入循环后，程序将当前数字存放在\verb|%eax|中，并将\verb|2*%eax|与下一个数字（\verb|0x4(%ebx)|）进行比较，若两者相等，则跳过\verb|explode_bomb|。因此剩下的数字的值分别是前一个数字的两倍。

综合上述分析可知，由于第一个数字是\verb|1|，因此接下来的每一个数字分别是\verb|2、4、8、16、32|。

\end{enumerate}

\item 实验结果

将第二关的答案输入\verb|ans.txt|中并运行程序：

\begin{lstlisting}
$ echo "1 2 4 8 16 32" >> ans.txt
$./bomb ans.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That is number 2.  Keep going!
\end{lstlisting}

顺利通过！

\end{enumerate}

\subsubsection{阶段3 条件分支}
\begin{enumerate}
\item 任务描述

找出代码段中的条件分支，并通过输入正确的数字破解关卡。

\item 实验设计

本阶段实验主要分为以下几个步骤：
\begin{enumerate}
\item 判断第一个参数的范围，并在该范围内随便选取一个数；
\item 使用gdb找出给定第一个参数后，第二个参数的值。
\end{enumerate}

\item 实验过程

\begin{enumerate}
\item 判断第一个参数的范围

在\verb|phase_3|的开头部分有以下代码段：
\begin{lstlisting}
8048bd9:	e8 32 fc ff ff       	call   8048810 <__isoc99_sscanf@plt>
8048bde:	83 c4 10             	add    $0x10,%esp
8048be1:	83 f8 01             	cmp    $0x1,%eax // 参数需要多于一个
8048be4:	7f 05                	jg     8048beb <phase_3+0x34>
8048be6:	e8 36 05 00 00       	call   8049121 <explode_bomb>
8048beb:	83 7c 24 04 07       	cmpl   $0x7,0x4(%esp) // 第一个参数<=7
8048bf0:	77 66                	ja     8048c58 <phase_3+0xa1>
...
8048c58:	e8 c4 04 00 00       	call   8049121 <explode_bomb>
\end{lstlisting}

根据前面关卡的分析，很容易知道\verb|0x4+%esp|是第一个参数的地址。在代码段中地址\verb|0x8048beb|处将\verb|0x4(%esp)|的值和\verb|0x7|作比较，如果第一个参数比7大，就会跳转到\verb|0x8048c58|处，即\verb|call| \verb|explode_bomb|语句处。因此我们可以确定第一个参数需要小于或等于\verb|7|。接着，根据比较指令使用的是\verb|ja|指令，可以知道第一个参数是无符号整形数，因此第一个参数还需要大于或等于\verb|0|。

下面从$\{0, 1\dots7\}$内尝试选取第一个参数，不妨选1。

\item 在给定第一个参数后，确定第二个参数的值

接着分析代码段：

\begin{lstlisting}
8048bf2:  8b 44 24 04          	mov    0x4(%esp),%eax //将第一个参数赋给%eax
8048bf6:  ff 24 85 80 a0 04 08 	jmp    *0x804a080(,%eax,4) // 根据%eax转跳
8048bfd:  b8 77 01 00 00       	mov    $0x177,%eax
8048c02:  eb 05                	jmp    8048c09 <phase_3+0x52>
8048c04:  b8 00 00 00 00       	mov    $0x0,%eax
8048c09:  2d ac 01 00 00       	sub    $0x1ac,%eax
8048c0e:  eb 05                	jmp    8048c15 <phase_3+0x5e>
8048c10:  b8 00 00 00 00       	mov    $0x0,%eax
8048c15:  05 fa 01 00 00       	add    $0x1fa,%eax
8048c1a:  eb 05                	jmp    8048c21 <phase_3+0x6a>
8048c1c:  b8 00 00 00 00       	mov    $0x0,%eax
8048c21:  2d c9 03 00 00       	sub    $0x3c9,%eax
8048c26:  eb 05                	jmp    8048c2d <phase_3+0x76>
8048c28:  b8 00 00 00 00       	mov    $0x0,%eax
8048c2d:  05 c9 03 00 00       	add    $0x3c9,%eax
8048c32:  eb 05                	jmp    8048c39 <phase_3+0x82>
8048c34:  b8 00 00 00 00       	mov    $0x0,%eax
8048c39:  2d c9 03 00 00       	sub    $0x3c9,%eax
8048c3e:  eb 05                	jmp    8048c45 <phase_3+0x8e>
8048c40:  b8 00 00 00 00       	mov    $0x0,%eax
8048c45:  05 c9 03 00 00       	add    $0x3c9,%eax
8048c4a:  eb 05                	jmp    8048c51 <phase_3+0x9a>
8048c4c:  b8 00 00 00 00       	mov    $0x0,%eax
8048c51:  2d c9 03 00 00       	sub    $0x3c9,%eax
8048c56:  eb 0a                	jmp    8048c62 <phase_3+0xab>
8048c58:  e8 c4 04 00 00       	call   8049121 <explode_bomb>
8048c5d:  b8 00 00 00 00       	mov    $0x0,%eax
8048c62:  83 7c 24 04 05       	cmpl   $0x5,0x4(%esp)
8048c67:  7f 06                	jg     8048c6f <phase_3+0xb8>
8048c69:  3b 44 24 08          	cmp    0x8(%esp),%eax // 将第二个参数与%eax比较
8048c6d:  74 05                	je     8048c74 <phase_3+0xbd>
8048c6f:  e8 ad 04 00 00       	call   8049121 <explode_bomb>
8048c74:  8b 44 24 0c          	mov    0xc(%esp),%eax
\end{lstlisting}

上述代码首先根据\verb|%eax|的值跳转\verb|0x804a080|中存储的地址，接着进行一系列的跳转改变\verb|%eax|的值。最后将第二个参数（\verb|0x8(%esp)|）与\verb|%eax|作比较，若两个数相等，则跳过\verb|explode_bomb|。

分析上述转跳表的逻辑看似是本关卡的必经之路，但我们很容易发现：虽然转跳表改变了\verb|%eax|的值，我们只需要在最后保证第二个参数的值与转换后的\verb|%eax|一样就行了。因此我们假定第一个参数为\verb|1|，并在\verb|0x8048c69|处打上断点，在断点处查看\verb|%eax|的值即可。

\begin{lstlisting}
gdb ./bomb
(gdb) b *0x8048c69
Breakpoint 1 at 0x8048c69
(gdb) r ans.txt                                             
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That is number 2.  Keep going!
1 0 // 测试输入，假设第一个参数为1

Breakpoint 1, 0x08048c69 in phase_3 ()
(gdb) p $eax
$1 = -891 // 第二个参数需为-891
\end{lstlisting}

使用\verb|gdb|调试后可以和轻松的知道第二个参数为\verb|-891|，而不需要分析分支转调表。

\end{enumerate}

\item 实验结果

将第三关的答案输入\verb|ans.txt|中并运行程序即可顺利通过：

\begin{lstlisting}
$ echo "1 -891" >> ans.txt
$./bomb ans.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That is number 2.  Keep going!
Halfway there!
\end{lstlisting}

\end{enumerate}

\subsubsection{阶段4 递归调用}
\begin{enumerate}
\item 任务描述

查看反汇编代码中递归函数的逻辑以及期望的返回值，用C语言复现递归函数并遍历所有输入找到期望的返回值。

\item 实验设计

\begin{enumerate}
\item 查看\verb|phase_4|的反汇编代码，并确定输入参数的类型、范围以及数量；
\item 查看期待的递归函数\verb|func4|的返回值；
\item 分析\verb|func4|函数并使用C语言复现；
\item 遍历函数的输入，找出期望的返回值对应的输入。
\end{enumerate}

\item 实验过程

\begin{enumerate}
\item 查看\verb|phase_4|的反汇编代码，并确定输入参数的类型、范围以及数量 \label{l2}

查看汇编代码中读取输入的部分，如下所示：
\begin{lstlisting}
8048cfb: 50              push   %eax
8048cfc: 68 ef a1 04 08  push   $0x804a1ef // 格式化字符串
8048d01: ff 74 24 2c     push   0x2c(%esp)
8048d05: e8 06 fb ff ff  call   8048810 <__isoc99_sscanf@plt>
8048d0a: 83 c4 10        add    $0x10,%esp
8048d0d: 83 f8 02        cmp    $0x2,%eax // 需要输入两个参数
\end{lstlisting}

根据上述代码分析，可以使用\verb|gdb|查看位于\verb|0x804a1ef|格式化字符串：
\begin{lstlisting}
$ gdb ./bomb
(gdb) x /s 0x804a1ef
0x804a1ef:      "%d %d"
\end{lstlisting}
可以确定，本关卡要求输入的参数为两个整形数字。

继续分析代码：
\begin{lstlisting}
8048d12: 83 7c 24 04 0e cmpl $0xe,0x4(%esp) // 第一个参数<= 0xe
8048d17: 76 05          jbe  8048d1e <phase_4+0x3b> // jbe:第一个参数为无符号数
8048d19: e8 03 04 00 00 call 8049121 <explode_bomb>
8048d1e: 83 ec 04       sub  $0x4,%esp
\end{lstlisting}
可以确定第一个参数（\verb|0x4(%esp)|）的范围是$\{x \in \mathcal{Z} | 0 \leq x \leq 14\}$（\verb|0xe=14|）。

根据以下代码可以直接确定第二个参数的值：
\begin{lstlisting}
8048d36: 83 7c 24 08 1b cmpl   $0x1b,0x8(%esp) // 第二个参数为27
8048d3b: 74 05          je     8048d42 <phase_4+0x5f>
8048d3d: e8 df 03 00 00 call   8049121 <explode_bomb>
8048d42: 8b 44 24 0c    mov    0xc(%esp),%eax
\end{lstlisting}
当\verb|0x8(%esp)|（即第二个参数）的值为\verb|0x1b=27|时，跳过\verb|explode_bomb|。因此，第二个参数为\verb|27|。


\item 查看期待的递归函数\verb|func4|的返回值

找到调用函数\verb|func4|后使用返回值\verb|%eax|的代码段：
\begin{lstlisting}
8048d29: e8 5c ff ff ff  call   8048c8a <func4>
8048d2e: 83 c4 10        add    $0x10,%esp
8048d31: 83 f8 1b        cmp    $0x1b,%eax // func4 returns 27
8048d34: 75 07           jne    8048d3d <phase_4+0x5a>
...
8048d3d: e8 df 03 00 00  call   8049121 <explode_bomb>
\end{lstlisting}
分析上述代码段可知，函数\verb|func4|需要返回\verb|0x1b=27|才能跳过爆炸。

\item 分析函数\verb|func4|接收的参数

找到调用函数\verb|func4|前的部分代码：
\begin{lstlisting}
8048d1e: 83 ec 04        sub    $0x4,%esp
8048d21: 6a 0e           push   $0xe
8048d23: 6a 00           push   $0x0
8048d25: ff 74 24 10     push   0x10(%esp) // 输入字符串中的第一个参数
8048d29: e8 5c ff ff ff  call   8048c8a <func4>
\end{lstlisting}
分析上述代码可知，\verb|func4|一共接收三个参数，分别是\verb|0x10(%esp)|、\verb|0x0|以及\verb|0xe|。我们输入的第一个参数的位置本来是\verb|0x4+%esp|，但由于在调用\verb|func4|函数之前\verb|%esp|的值减少了\verb|0x4|，并且还将两个数（\verb|0xe|与\verb|0x0|）进行了压栈，因此\verb|0x10(%esp)|即是我们输入字符串中的第一个参数（\verb|0x10=0x4+0x4+0x4+0x4|）。

考虑到\verb|C|调用约定中函数参数使用反向压栈的方式，调用\verb|func4|函数的\verb|C|语句为：

\verb|func4(param1, 0, 14);|

其中，\verb|param1|是我们从输入字符串的第一个参数。

\item 分析\verb|func4|函数并使用C语言复现

分析参数在\verb|func4|中存放的位置：
\begin{lstlisting}
8048c8f: 8b 54 24 10     mov    0x10(%esp),%edx // p1=param1
8048c93: 8b 74 24 14     mov    0x14(%esp),%esi // p2=0
8048c97: 8b 4c 24 18     mov    0x18(%esp),%ecx // p3=14
\end{lstlisting}
从上述代码中不难看出，输入的三个参数分别存放在\verb|%edx|、\verb|%esi|以及\verb|%ecx|中。

接着分析参数在\verb|func4|中的计算过程：
\begin{lstlisting}
8048c9b: 89 c8     mov    %ecx,%eax // %eax=p3
8048c9d: 29 f0     sub    %esi,%eax // %eax=p3-p2
8048c9f: 89 c3     mov    %eax,%ebx // %ebx=p3-p2
8048ca1: c1 eb 1f  shr    $0x1f,%ebx // %ebx>>=31,即%ebx=(p3-p2<0?1:0)
8048ca4: 01 d8     add    %ebx,%eax // %eax=p3-p2+(p3-p2<0?1:0)
8048ca6: d1 f8     sar    %eax // %eax=(p3-p2+(p3-p2<0?1:0))/2
8048ca8: 8d 1c 30  lea    (%eax,%esi,1),%ebx // %ebx=(p3-p2+(p3-p2<0?1:0))/2+p2
\end{lstlisting}
经过参数一系列的转化，最终得到了\verb|%ebx|的值。这个值十分重要，因为\sout{这是我历经千辛万苦得出} \sout{的结论}，接下来的代码段中会根据\verb|%ebx|的值进行转调并递归。

接着分析递归调用的转调代码：
\begin{lstlisting}
8048cab: 39 d3           cmp    %edx,%ebx // p1>%ebx?
8048cad: 7e 15           jle    8048cc4 <func4+0x3a>
8048caf: 83 ec 04        sub    $0x4,%esp
8048cb2: 8d 43 ff        lea    -0x1(%ebx),%eax
8048cb5: 50              push   %eax
8048cb6: 56              push   %esi
8048cb7: 52              push   %edx
8048cb8: e8 cd ff ff ff  call   8048c8a <func4>
8048cbd: 83 c4 10        add    $0x10,%esp
8048cc0: 01 d8           add    %ebx,%eax // %eax=func4(p1, p2, ebx-1)+ebx;
8048cc2: eb 19           jmp    8048cdd <func4+0x53>
8048cc4: 89 d8           mov    %ebx,%eax
8048cc6: 39 d3           cmp    %edx,%ebx // p1<%ebx?
8048cc8: 7d 13           jge    8048cdd <func4+0x53>
8048cca: 83 ec 04        sub    $0x4,%esp
8048ccd: 51              push   %ecx
8048cce: 8d 43 01        lea    0x1(%ebx),%eax
8048cd1: 50              push   %eax
8048cd2: 52              push   %edx
8048cd3: e8 b2 ff ff ff  call   8048c8a <func4>
8048cd8: 83 c4 10        add    $0x10,%esp
8048cdb: 01 d8           add    %ebx,%eax// %eax=func4(p1, ebx+1, p3)+ebx;
\end{lstlisting}
分析上述代码，并结合前面对\verb|ebx|的分析，不难得出\verb|func4|的\verb|C|语言代码：
\begin{lstlisting}
int func4(int p1, int p2, int p3)
{
    int ebx = (p3-p2+(p3-p2<0?1:0))/2+p2;
    if (p1 == ebx)
        return p1;
    if (p1 < ebx)
        return func4(p1, p2, ebx-1) + ebx;
    if (p1 > ebx)
        return func4(p1, ebx+1, p3) + ebx;
}
\end{lstlisting}

\item 遍历函数的输入，找出期望的返回值对应的输入

根据\ref{l2}中的分析可知，第一个参数的范围是$\{0,1\dots14\}$，第二个参数为\verb|0|，第三个参数为\verb|14|。因此我们只需要遍历第一个参数即可得出返回值为\verb|27|时对应的输入。

在\verb|main|函数中：
\begin{lstlisting}
int main(){
    for (int p1 = 0; p1 <= 14; ++p1){
        int ret = func4(p1, 0, 14);
        if (ret == 27){
            printf("p1 = %d, ret = %d\n", p1, ret);
            break;
        }
    }
    return 0;
}
\end{lstlisting}
将\verb|main|函数与\verb|func4|函数写入\verb|analyze_phase_4.c|，编译并运行：
\begin{lstlisting}
$ gcc analyze_phase_4.c -o main
$ ./main
p1 = 9, ret = 27
\end{lstlisting}
可以知道，输入的第一个参数为\verb|9|。

\end{enumerate}

\item 实验结果

将参数\verb|9|与\verb|27|输入到\verb|ans.txt|中并运行程序：
\begin{lstlisting}
$ echo "9 27" >> ans.txt
$ ./bomb ans.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That is number 2.  Keep going!
Halfway there!
So you got that one.  Try this one.
\end{lstlisting}
\sout{历经千辛万苦终于}顺利通过！

\end{enumerate}

\subsubsection{阶段5 指针}
\begin{enumerate}
\item 任务描述
\item 实验设计
\item 实验过程
\item 实验结果
\end{enumerate}

\subsubsection{阶段6 链表/指针/结构}
\begin{enumerate}
\item 任务描述
\item 实验设计
\item 实验过程
\item 实验结果
\end{enumerate}

\subsubsection{阶段7 二叉查找树}
\begin{enumerate}
\item 任务描述
\item 实验设计
\item 实验过程
\item 实验结果
\end{enumerate}

\end{document}